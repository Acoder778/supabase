import Layout from '~/layouts/DefaultGuideLayout'
export const meta = {
  id: 'auth-security',
  title: 'Security',
  description: 'Important information about security and privacy when using Supabase Auth.',
}

Supabase's priority is to help you build secure applications. This guide sheds light on the measures we take to secure Supabase Auth and provides guidance for building secure applications.

<Admonition type="note">
  {' '}
  To report a security vulnerability with Supabase Auth or any other Supabase service, follow the instructions outlined in our [security.txt](https://supabase.com/.well-known/security.txt).{' '}
</Admonition>

## Credentials

Supabase Auth always receives credentials such as email addresses, phone numbers, passwords, and one-time passwords as `POST` requests over TLS. This method ensures that the credentials are not logged as part of the URL in HTTP request logs. Magic links are an exception to this rule. They use a URL to encode a short-lived, hard-to-guess code, which sends a `GET` request to Supabase Auth. The code can only be used once.

Passwords are hashed using the [bcrypt](https://en.wikipedia.org/wiki/Bcrypt) password hashing function with a difficulty level of 10. The hashed passwords are stored in your project's database.

Supabase Auth stores each project's user information in isolated Postgres databases. Therefore, security incidents involving other projects will not affect your project.

Social logins (e.g., Login with GitHub) often use the OAuth authorization protocol. Supabase Auth does not store the token issued by the provider. However, it makes the token available to your browser's app if you need further access to it. Each subsequent sign-in with OAuth updates the user's identifying information in Supabase Auth.

### Automatic linking

When users have the same email address across different social login providers, they only get one single user account in Supabase Auth. We believe this is the most common behavior for modern applications.

<Admonition type="warn">
  Not all social login providers can be trusted! Some providers allow social login with your application even if the user's email address is not confirmed. This can have the unintended side-effect of allowing attackers to abuse a social login provider to gain access to a legitimate user's account. Always verify the behavior of social login providers to determine whether user email addresses are confirmed before allowing social login access.
</Admonition>

### Passwordless Sign-in with Magic Links

Supabase Auth offers passwordless sign-in with magic links. These links are URLs that contain a single-use, hard-to-guess code. By default, the URL is hosted by the Supabase Auth server and immediately redirects back to your app.

However, it's important to note that email messages are inherently insecure, even though the default SMTP settings from Supabase Auth attempt to deliver email messages via TLS to the receiving server. Some email clients, enterprise and end-user security software inspect email messages for malware. Often this software will visit links in messages (sometimes multiple times) in an attempt to scan for viruses. Unfortunately, this has the effect of signing up a user without their knowledge or express consent. It also provides an access and refresh token to this software, which could be used maliciously.

We do not recommend using magic link sign-in with the default settings for applications that require a high level of authentication security. To prevent this issue, you can modify the magic link email template to point to your application. This way, you can present the user with a button that leads to the magic link URL.

## User Account Information

Supabase Auth stores user account information in your project's database. This information is provided by your application or collected from third-party identity providers.

However, it's important to note that email addresses, phone numbers, and other personally identifiable information are not encrypted in your project's database. If you need to store encrypted data for users, we recommend using Supabase Vault. It's a secure and straightforward way to achieve this.

### Protection Against User Enumeration

User enumeration is a technique used by third-parties to gather information about the existence of accounts on a system. Although this technique does not necessarily indicate malicious behavior, it may be used as part of such an effort.

Although [industry best practices](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#authentication-and-error-messages) recommend masking the existence of accounts in a system to unauthorized parties, this can be challenging to achieve, particularly when dealing with a system using email and password login. The following are some examples of where applications typically fail to mask the existence of an account:

1. **Side-channel leak via password hashing.**  
   Even if an application returns ambiguous messages such as "Email or password not correct," the login request will take longer if the account exists. This is because password-hashing functions take hundreds of milliseconds to compare a stored password hash with the provided password. One solution is making all login requests have an equal and long duration to obfuscate the fact. However, this is only a partial solution as attackers can intentionally overload a system and still gather information from the side-channel.
2. **Side-channel leak via email or SMS.**  
   With passwordless login or flows such as forgot password, information about whether an account exists in the system can leak even if the application returns an ambiguous message such as "If you have an account an email has been sent." This is because the final part of the request handling needs to send an email message or SMS using a third-party system, and requests last longer when an account exists. Sometimes applications add per-account rate-limiting to stop abuse, but this can exacerbate the problem as rate-limiting counts toward accounts that exist, not those that do not. Thus attackers can intentionally trigger rate-limits and gather information that way.
3. **Account creation vs. login.**  
   Applications often obfuscate login requests, but not account creation requests, which can leak information and confuse legitimate users. Login flows typically show a message like "Email or password is not correct," whereas sign-up flows usually show "an account with this email address already exists." The problem compounds if the user has both a social login and a password-based login. In this situation, you can tell the user that there is already an account and redirect to the social login provider (which again leaks the information) or return a server error (still leaks the information).

Enabling some form of abuse protection for your project, such as setting adequate per-IP rate-limiting or a Turing test system like CAPTCHA, can partially mitigate or make large scale user enumeration attacks inefficient.

## Access and refresh tokens

A successful user login triggers Supabase Auth to issue an access and refresh token.

Access tokens are in the form of a JSON Web Token (JWT) and include most standard JWT claims for this purpose. Each JWT is signed using the `HS256` algorithm (HMAC with SHA256). The secret key used to derive the signature is generated from a 512 bit, cryptographically-secure pseudo random number generator when a project is initially created. This key is stored encrypted in our database, so Supabase staff are unable to readily access it.

To give developers full ownership of their projects, this key is visible to you only in your project's dashboard. Never share this value with parties you don't completely trust.

<Admonition type="tip">
  You can rotate the JWT signing key if you suspect it has leaked. Rotating keys on a regular basis
  is a good practice. Rotating a key means that all access tokens will immediately become invalid.
  Remember to update all services that use Supabase Auth access tokens with the rotated secret.
</Admonition>

Access tokens are short lived, and you can configure their validity duration in the project's settings page. The default value is 1 hour, which is common across the industry. We do not recommend exceeding this, and recommend using a shorter value if it is sensible for your application. Durations of less than 5 minutes are discouraged as computers may have significant clock skew that introduce confusing application errors and behaviors which are difficult to debug. Shortening the duration also increases the application's dependence of the uptime of the authentication server.

Access tokens can be readily shared between components of your application, including the browser, Supabase services (such as PostgREST and Edge Functions), or other servers that you control. Due to their short lifetime, any security incident involving access tokens will have a time-limited blast radius.

Always pass access tokens as headers or cookies rather than URL query parameters (regardless of request methods) to prevent them from appearing in access logs. When using access tokens in Edge Functions or other API servers, take care to not accidentally write them to logs.

Supabase Auth returns the access token and refresh token to your browser application via the URL fragment (anything after the `#` sign). This prevents browsers sending the data to the server. URL fragments are only accessible to the JavaScript running in your browser.

Access tokens are never stored by Supabase Auth or other services, regardless if they are valid or not. We recommend that you avoid storing them in Edge Functions or otherAPI servers.

<Admonition type="tip">
  Sometimes it is necessary to record or identify if a server has seen an access token (for complex
  rate limiting or other features). Should you find yourself needing such functionality, a good
  approach is to record the JWT's signature instead of the whole string or some derivative hash. The
  signature can be found after the last period `.` in the JWT string. Always validate the JWT
  signature before you record such values!
</Admonition>

If you use Supabase Auth in Android applications, though, there is a non-negligible risk that other applications installed on the device may be able to maliciously (or otherwise) intercept both the access and refresh tokens on successful sign in. This is because Android implements URL callbacks by invoking all applications registered to listen to the URL. Thus, any application may register to listen to URLs that you control, and there's not much you can do to prevent this from occurring. The industry standard way to mitigate this risk is to use a different exchange mechanism with Supabase Auth called PKCE (Proof Key for Code Exchange). At this time Supabase Auth **does not implement PKCE** but it is on our roadmap.

<Admonition type="tip">
  Although Supabase Auth does not implement the PKCE mechanism which would completely mitigate the
  issue where other applications may be listening in for your user's access and refresh tokens, we
  recommend [adding funcionatlity in your app that would periodically scan for other applications
  installed on the device that claim to handle your application's
  URLs](https://medium.com/androiddevelopers/package-visibility-in-android-11-cc857f221cd9). Should
  you find one you can't recognize, indicate to the user prior sign in to remove the offending
  application.
</Admonition>

Refresh tokens are long-lived opaque strings that are issued by Supabase Auth together with access tokens. They are named after their purpose: to refresh the access token for the particular user session. A refresh token can usually be used only once or a few times within a time period. Note that a refresh token does not uniquely identify an authenticated user session on a particular browser.

Because refresh tokens can generally be used only once you should not be sharing them between different components of your application. For example, they should not be sent to Supabase functions or other API servers. Importantly, though, they can be shared with your hosting server but only to support server-side rendering functionality of your app.

<Admonition type="tip">
Your browser based application can share the access and refresh token with your hosting server by using cookies, instead of calling requests. Below is a snippet of code you can use to instruct the Supabase client library to keep the cookies up-to-date.

```typescript
supabase.auth.onAuthStateChange((event, session) => {
  if (event === 'SIGNED_OUT' || event === 'USER_DELETED') {
    // delete cookies on sign out
    const expires = new Date(0).toUTCString()
    document.cookie = `my-access-token=; path=/; expires=${expires}; SameSite=Lax; secure`
    document.cookie = `my-refresh-token=; path=/; expires=${expires}; SameSite=Lax; secure`
  } else if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {
    const maxAge = 100 * 365 * 24 * 60 * 60 // 100 years, never expires
    document.cookie = `my-access-token=${session.access_token}; path=/; max-age=${maxAge}; SameSite=Lax; secure`
    document.cookie = `my-refresh-token=${session.refresh_token}; path=/; max-age=${maxAge}; SameSite=Lax; secure`
  }
})
```


</Admonition>

We've identified the following legitimate reasons that may cause a refresh token to be used more than once in a short timespan:

1. **Serving a request from a web server that does server-side rendering.**  
   The access token sent by the browser to the server may have expired, but the user's session is still active. The server will then refresh the access token, which will invalidate the refresh token on the server side. Once the request is served to the browser, the Supabase client library will trigger another request to refresh the access token with the token that the server used. Usually the time difference between both refresh calls is less than 1 second, though may vary up to 10 seconds or more.
2. **Multi-tab synchronization issues.**  
   Should your browser based application be open in multiple browser tabs, your application's code may submit the same refresh token from each tab simultaneously. It is often too difficult to properly synchronize and coordinate data between multiple tabs. Fortunately though, simultaneous use of refresh tokens is rare and does not produce adverse effects in applications provided the refresh calls occur within the refresh token reuse period.
3. **Retry logic or bugs.**  
   Requests are known to fail for various reasons, and bugs can't be ruled out both in your application's code or the client libraries by Supabase. Thus retry behavior may trigger multiple refresh token validations in such cases.

<Admonition type="tip">
  You can configure whether Supabase Auth allows the reuse of refresh tokens multiple times and an
  appropriate reuse window for your application. If you expect your app not to need the above listed
  legitimate reasons we recommend using a very short reuse window no longer than 10 seconds.
</Admonition>

Refresh tokens are stored hashed with the SHA-256/224 hash function in your project's database. Some older versions of Supabase Auth stored refresh tokens in plaintext in the database. Plaintext tokens do not have the `H:` prefix. We do this to prevent unauthorized parties from impersonating users, should the contents of the database leak or be accidentally accessed.

Supabase does not store refresh tokens elsewhere.

<Admonition type="tip">
  Sometimes it is necessary to record or identify if a server has seen a refresh token (for complex
  rate limiting or other features). Should you find yourself needing such functionality, a good
  approach is to store a hash of the refresh token value. Since refresh tokens are generated with a
  cryptographically-secure pseudo-random number generator they do not need to be hashed with a
  password hashing function like Argon2, bcrypt or scrypt. We recommend using any of the SHA-256
  (especially the truncated version: SHA-256/224), SHA-512 (especially the truncated versions:
  SHA-512/256 or SHA-512/384), or any of the SHA-3 functions.
</Admonition>

Refresh tokens are intentionally not bound to the browser with cookies, IP addresses, cryptographic keys or other mechanisms as we believe these have only marginal security benefits while introducing significant developer experience challenges.

We also do not recommend using any additional obfuscation measures to store access and refresh tokens in the browser, like encrypting values in the browser's local or session storage, cookies or the indexed database. This recommendation is based on our experience that such measures only marginally contribute to the overall security while negatively impacting developer experience.

We base our security recommendations on the assumption that the end-user's devices are not compromised. This is because there is not much that can be done to protect information stored in the browser when the end-user's operating system or browser has been compromised. Attackers will be able to extract any and all information.

<Admonition type="tip">
  Although it is difficult to protect users when their device is compromised, it is possible to
  implement some application-level security mechanisms to ensure the authenticity and awareness of
  the user. For example, sensitive user actions that may modify certain settings or grant access to
  protected data should be gated with additional authentication layers, or send email notifications
  to users when they occur.
</Admonition>

<Admonition type="tip">
  There are some social engineering attacks that instruct users without a technical background to
  access the browser's developer console in an effort to extract access and refresh tokens. We
  recommend that your application emit informational text with `console.log()` to inform users
  without a technical background never to divulge information found in the console. [This text can
  be styled with some CSS to make it
  prominent.](https://developer.chrome.com/docs/devtools/console/api/#styling_console_output_with_css)
</Admonition>

## Abuse Protection

Your Supabase Auth server uses industry-standard denial of service and bot protection, which is not configurable. However, this protection is in place to ensure the reliability of Auth and other Supabase services and is not intended as a general abuse protection.

Your project's Auth server does have built-in IP-based rate limiting. However, note that IP-based rate limiting can often result in false positives. This means that legitimate users attempting to use your app at the same time may trigger what appears to be a rate-limit breach. We commonly see this in the following scenarios:

1. **IPv4 with NAT.**  
   Due to the worldwide shortage of IPv4 addresses, internet service providers use a technique called NAT (Network Address Translation) to share one IP address with many end-users.
2. **Corporate users.**  
   Corporations often route office internet traffic through one or more IPv4 addresses. This may be common in enterprise applications where many employees sign in at once during common hours of the day.
3. **Internet security software.**  
   Some end-users use internet security software which routes or inspects internet traffic via centralized servers before showing the content to the user. This means that Supabase Auth will rate-limit based on the IP address of the server, causing multiple users of the same software to have a degraded experience.
4. **VPN.**  
   Some end-users use Virtual Private Networks to protect their internet connection or to access content from other geographical locations. This means that Supabase Auth could trigger rate-limit protection since many VPN users share one IPv4 address.

Due to these common cases, rate-limit protection per IP address is quite generous but is not effective against distributed attacks.

Supabase Auth supports using a [Turing test](https://en.wikipedia.org/wiki/CAPTCHA) in the form of a CAPTCHA via the [hCaptcha](https://www.hcaptcha.com) service to distinguish humans from robots. You can enable this protection in your project's dashboard.

<Admonition type="tip">
  The [W3C does not recommend the use of CAPTCHA](https://www.w3.org/TR/turingtest/) or other Turing
  tests for most web applications as they pose challenges with accessibility.
</Admonition>

## Redirect URLs

Supabase Auth allows you to redirect back to different URLs on successful authentication. Your client app can specify the URL to redirect back to using the `redirectTo` parameter.

In sophisticated attacks, this parameter may come from a malicious source. To mitigate this risk, Supabase Auth implements an allow list which is consulted prior to sending a redirect response. If the redirect parameter does not fall in the URL allow list, the Site URL is used.

The allow list can be a simple list of exactly matching URLs, but it also supports wildcard characters to match them as a pattern.

<Admonition type="tip">
  You can configure the URL allow list in the [Authentication General Settings
  page](https://app.supabase.com/project/_/auth/settings) under Redirect URLs.
</Admonition>

However, when using wildcard patterns, you need to be careful as you may be opening up your application to a larger attack surface. Here are some do's and don'ts:

**Don'ts:**

- `**`  
  This pattern would match any redirect URL.
- `com.mobile.app.*://**`  
  This pattern would match any iOS application with a package name that starts with `com.mobile.app.` An attacker can use this to call on those apps on a user's device.
- `https://*.com/**`  
  This pattern would match any URL on the `.com` domain name. An attacker can use this to redirect back to any website they control.

**Do's:**

- `https://app.example.com/**`  
  This is the recommended form for most project use cases on the web. Any redirects to the `app.example.com` domain will be allowed with any path. If your project needs to support multiple such domains, add multiple entries like this.
- `com.mobile.app://**`  
  This is the recommended form for most project use cases on iOS. Any redirects to the `com.mobile.app` application will be allowed with any path. If your project needs to support multiple applications, add multiple entries. Avoid using wildcards in the URL scheme!

<Admonition type="tip">
  If you use exact or very specific URLs, make sure you always include a trailing slash `/` as that
  is the proper valid form of URLs. Correct form: `https://app.example.com/*/sign-in/`. Incorrect
  form: `https://app.example.com/*/sign-in`.
</Admonition>

export const Page = ({ children }) => <Layout meta={meta} children={children} />

export default Page
